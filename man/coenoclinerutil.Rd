% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/coenoclinerutil.R
\name{GradLocs}
\alias{BinomGaussPar}
\alias{DropMissingSpec}
\alias{Gauss2betaPar}
\alias{GradLocs}
\alias{coenorun1}
\title{Utility Functions for 'coenocliner' Package}
\usage{
GradLocs(n, xrange, yrange)

BinomGaussPar(nsp, xrange, yrange, buffer = 2, tsd = 0.1)

Gauss2betaPar(gausspar, shape = c(0.5, 6.5), range = 5)

DropMissingSpec(comm)

coenorun1(sim, tot = 1)
}
\arguments{
\item{n}{Number of SUs.}

\item{xrange,yrange}{Desired range of gradients.}

\item{nsp}{Number of species.}

\item{buffer}{Width of buffer zone for optima surrounding ranges.}

\item{tsd}{Standard deviation of tolerance in log-Normal
distribution, in log scale}

\item{gausspar}{Gaussian response parameters for species as
returned by \code{BinomGaussPar}.}

\item{shape}{Random log-uniform range of shape parameters \eqn{alpha}
and \eqn{gamma} of response function}

\item{range}{Range of beta response in $t$ (\sQuote{sd}) units of
Gaussian response function.}

\item{comm}{Community data.}

\item{sim}{One simulated community.}

\item{tot}{Binomial total in \code{sim}.}
}
\description{
Functions to automated simulation routines using \pkg{coenocliner}
package.


}
\section{Functions}{
\itemize{
\item \code{GradLocs}: Gradient Locations

\item \code{BinomGaussPar}: Gaussian Parameters for Binomial Response.

\item \code{Gauss2betaPar}: Translate Gaussian parameters into
corresponding beta response parameters.

\item \code{DropMissingSpec}: Drop missing species from the data.

\item \code{coenorun1}: Takes one simulated community for
ordination with GO, NMDS, CA and DCA and returns average Procrustes
precision
}}
\examples{
require(coenocliner) || stop("examples need 'coenocliner' package")
## small simulation
nsim <- 10
npoints <- 50
## generate a set of species parameters over the maximum extent
sp <- replicate(nsim, BinomGaussPar(800, 8, 4))
## sample much narrower proportion of the space
xy <- replicate(nsim, GradLocs(npoints, 3, 2))
## Simulations: these can be easily parallelized using mclapply
## (Linux, Mac) or parSapply (all).
sapply(seq_len(nsim), function(i)
     coenocline(xy[,,i], "gaussian", sp[,i], countModel="bernoulli"))
}

